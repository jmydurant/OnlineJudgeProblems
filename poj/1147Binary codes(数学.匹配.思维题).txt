#include <cstdio>  //具体思想见下。。。。
#include <cstring>
#include <algorithm>
#include <queue>
#include <climits>
#define MIN(a,b) ((a)<(b)?(a):(b))
#define FOR(i,a,b) for(int i = (a);i<=(b);i++)
#define lson (ind<<1)
#define rson (ind<<1|1)
#define maxn 3004
using namespace std;

int nxt[maxn];
int f[maxn];
int k[maxn];
int main(void)
{
    int n;
    while(EOF != scanf("%d",&n))
    {
        int tot = 0;
        FOR(i,1,n) scanf("%d",&k[i]),tot += k[i];
        int one = 0;
        FOR(i,1,n)
        {
            if(k[i])
            {
                one++;
                nxt[i] = n - tot + one;
            }
            else
            {
                nxt[i] = i - one;
            }
        }
        FOR(i,1,n)
        {
            FOR(j,1,n)
            f[nxt[j]] = k[j];
            printf("%d%c",f[1],(i==n)?'\n':' ');
            memcpy(k,f,sizeof(k));
        }
    }
    return 0;
}
我们发现这个矩阵有个特点。将矩阵的每行看作一个01序列，得到一个序列集合A。然后将矩阵的最后一列移到第一列，其余列后移，然后将没行看作一个01序列，得到一个序列集合B。A与B一定是同一个集合。根据这个性质我们可以进一步得知，把后来经过列移动的矩阵按行字典序排序后可得到排序后的原矩阵。在这个排序变换过程中如果我们只关注矩阵的第一列，我们可以发现，相当于原矩阵的最后一列移到前面之后内部经过了一定的变换位置，变成了原矩阵的第一列。而再次进行这个操作（最后一列移到前面，排序）我们会发现原矩阵的第一列移动到了第二列的位置，并经过了相同的变换变为了原矩阵的第二列。也就是说我们只要找到了这个变换规律，那么我们一定可以由最后一列推出第一列、第二列……直到所有列。由于排序的规则是字典序，所以第一列一定是上面全是0，下面全是1。我们根据最后一列的01的个数与第一列相同，可以得知第一列是什么样的。最后一列移到最前面之后，进行排序时，如果两行的第一位（位于原最后一列中）相同，则排序后他们的前后顺序一定是不变的，因为后面的序列为原矩阵的序列，原矩阵是排过序的，所以在之前就排好了。这样规律就出来了，看原最后一列，现在的第一列，先只看为0的，第i个0会被排到第i行，再只看为1的，倒数第i个1会被排到倒数第i行。排序后我们可得知现在的最后一列一定就是排好序的原矩阵的最后一列。所以我们将最后一列填好。这样我们就得到了矩阵的两列，再进行同样的操作（将最后一列串到第一列，其余列后移，按上述方法对各行排序，填写最后一列）可得到矩阵的三列。
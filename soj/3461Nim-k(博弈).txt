#include <cstdio>   // 思路见下。。。
#include <cstring>
#define h(x) (1<<(x))
#define MAXN 1010
const int cap = 30;
int a[MAXN];
int tot[cap+1];
int n,k;
void cal(int floor)
{
    int m = h(floor);
    for(int i = 1;i<=n;i++)
        if(a[i] & m)
        tot[floor]++;
}
int main(void)
{
    int casenum; scanf("%d",&casenum);
    while(casenum--)
    {
        scanf("%d%d",&n,&k);
        for(int i = 1;i<=n;i++)
            scanf("%d",a+i);
        memset(tot,0,sizeof(tot));
        for(int i = 0;i<=cap;i++)
            cal(i);
        bool ok = false;
        for(int i = 0;i<=cap;i++)
            if(tot[i]%(k+1))
                ok = true;
        if(ok)
            printf("T\n");
        else
            printf("mm\n");
    }
    return 0;
}

/*方法是分别统计每组面包数量的二进制形式的从1到32位每一位的值的总和,(每一位要么为1,要么为0),如果每一位的总和%(k+1)都是0,那么先走着比输,否则必赢,证明如下:
从先走者的角度考虑,如果如果每一位的总和%(k+1)都是0,那么如果已经没有面包可取,那么他已经输了.
和普通nim问题类似,所以我们只用证明2点:

a.如果当前每一位的总和%(k+1)都是0,那么如果他还可以取,那么他取后,必然某些位总和
%(k+1)!=0,
b.如果某些位当前总和%(k+1)不为0,那么他必然有一种取法,使取后,每一位的总和
%(k+1)为0;

a点容易证明,现在证明b点,令e为最高一位,总和不为0的位.并且total[e]%(k+1)==t;
total[e]为e位的总和,t>0&&t<=k,那么必然存在t项,这t项的e位为1,那么我们先把这t项对应的行给取了,并把取了的
这t项对应的行放到一个队列里面,并然取的这t项在e的位置都变成0,然后另e等于下一个total[e]%(k+1)!=0的项,如果另b=total[e]%(k+1),如果队列里取了的行中,在e这一列中1的位数s大于于等于b,那么,我们把这些s中,随便取b项,把它们在
e的位置都变成0,就行.如果不及b,那么另w=k-队列的长度+s,如果w大于等于b,那么,我们把这s项中的1全部取0,并在剩下的
,还没有取的行中,任意取b-s项,并把所对应的行号加入队列中,(注意,取了这b-s项后,队列的长度同样不超过k).
如果w小于b,那么,已经取了的t项中,在e列,0的个数为k-w,而要让e这列的总和%(k+1)==0,还需要把k+1-b个0改成1,
因为w<b,所以w+1<=b,w<=b-1;
而k+1-b=k-(b-1)<=k-w,所以在已经取了的项中在e列的位置,存在的0的个数,超过需要改变的0的个数,只要把这些
0中随便取出k+1-b个,把它们改变成1就行了.(为什么可以变呢,因为,这行在前面某一列已经把一个1变成0了,所以即使把这项的
0变成1,最后剩下数字还是比原来小)
重复以上步骤,可以让所有在e列,total[e]%(k+1)!=0的位,在取完一次后,对于1到32的每个数i,都有total[i]%(k+1)==0;
所以,它的性质和普通nim问题是一致的,如果如果每一位的总和%(k+1)都是0,那么先走着比输,否则必赢.*/